# given a list G of permutations on W=[0..n-1], find the orbitals of the 
# group generated by them, i.e. the orbits on WxW. This only needs O(GW^2) operations
def orbitals(G, result="comp", pairing=False):
  n = len(G[0])
  dO = {(i,j):[(i,j)] for j in xrange(n) for i in xrange(n)}
  O = [[(i,j) for j in xrange(n)] for i in xrange(n)]
  update = True 
  while update:
   update = False
   dOk = copy(dO.keys())
#   import pdb; pdb.set_trace()
   for i,j in dOk:
      for g in G:
        s, t = g[i], g[j]
        # this does not preserve the natural pairing
        mi, ma = (min(O[i][j], O[s][t]), max(O[i][j], O[s][t]))
        if mi<ma:
           update = True
           dO[mi]+=dO[ma]
           for p,q in dO[ma]: 
              O[p][q] = mi
           dO.pop(ma)
        
  if result == "raw":
     return O
  d = [] 
  pa = dict()
  for i in xrange(n):
    for j in xrange(n):
      if O[i][j]==(i,j):
        d.append((i,j))
        if i<=j:
          pa[(i,j)]=O[j][i]
          pa[(j,i)]=O[i][j]
  if pairing == True:
     return d,pa
  else:  
     return d 
#  return [[O[i][j][0]*n+O[i][j][1] for j in range(n)] for i in range(n)]

def orbmats(G): # mainly for testing purposes
  oo=orbitals(G, result="raw")
  rep=list(set(flatten(oo,max_level=1)))
  n=len(G[0])
  A=[zero_matrix(n,n,sparse=True) for i in xrange(len(rep))]
  for k in xrange(len(rep)):
      for i in xrange(n):
          for j in xrange(n):
              A[rep.index(oo[i][j])][i,j]=1
  return A
 
# find the coefficients of expression of a sum of orbitals          
def mexpress(M,O,test=False):
  r = dict()
  if test==True:
    n = len(M[0])
    for i in xrange(n):
      for j in xrange(n):
        o = O[i][j]
        if o==(i,j):
          if M[i][j] != 0:
             r[(i,j)] = M[i][j]
        else:
          if M[i][j]!=M[o[0]][o[1]]:
             return False,i,j
    return r
  else:
    for i,j in O:
      if M[i][j] != 0:
        r[(i,j)] = M[i][j]
    return r
    
    
